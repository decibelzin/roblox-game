local RegisterCommand = require(game.ReplicatedStorage.Shared["register-command"])
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local PLAYER_DEFINITION = require(game.ReplicatedStorage.Shared.types["player.types"])
local PlayerModule = require(game.ServerScriptService.Server.framework.modules.player)()
local GROUPS_CONFIG = require(game.ReplicatedStorage.Shared.groups)

-- FunÃ§Ã£o para verificar se o jogador Ã© owner do jogo
local function isGameOwner(player)
    local success, result = pcall(function()
        return player:GetRankInGroup(game.CreatorId)
    end)

    if not success then
        return false
    end

    -- Rank 255 = Owner do grupo do jogo
    return result >= 255
end

-- FunÃ§Ã£o para listar grupos disponÃ­veis
local function listAvailableGroups()
    local groups = {}
    for groupName, groupData in pairs(GROUPS_CONFIG) do
        table.insert(groups, groupName)
    end
    return table.concat(groups, ", ")
end

RegisterCommand({
    name = "group",
    description = "DÃ¡ um grupo para um usuÃ¡rio",
    aliases = { "g" },
    permissions = { "owner", "admin" }
}, function(player, params, message)
    local username = params[1]
    local group = params[2]

    -- Verificar se os parÃ¢metros foram fornecidos
    if not username or not group then
        return
    end

    -- Verificar se o grupo existe
    if not GROUPS_CONFIG[group] then
        return
    end

    -- Verificar se estÃ¡ tentando definir o grupo "owner"
    if group == "owner" and not isGameOwner(player) then
        return
    end

    -- Buscar o usuÃ¡rio pelo nome
    local success, targetUserId = pcall(function()
        return Players:GetUserIdFromNameAsync(username)
    end)

    if not success then
        return
    end

    -- Verificar se o usuÃ¡rio estÃ¡ online
    local targetPlayer = Players:GetPlayerByUserId(targetUserId)
    if not targetPlayer then
        return
    end

    -- Obter dados do player alvo
    local targetPlayerData, targetPlayerClass = PlayerModule.get(targetPlayer, true)
    
    if not targetPlayerData or not targetPlayerClass then
        return
    end
    
    -- Tentar adicionar o grupo
    local addSuccess = targetPlayerClass.group.add(group)
    
    if addSuccess then
        print("âœ… Grupo adicionado com sucesso!")
        
        -- Sincronizar grupos apÃ³s adiÃ§Ã£o
        local groupSyncEvent = ReplicatedStorage:WaitForChild("GroupSyncEvent")
        
        -- Obter o novo grupo mais alto
        local priorities = {
            owner = 4,
            admin = 3,
            moderator = 2,
            ["vip-gold"] = 1
        }
        
        local highestGroup = nil
        local highestPriority = 0
        
        -- ApÃ³s addSuccess, recarregar os dados atualizados
        local updatedPlayerData, updatedPlayerClass = PlayerModule.get(targetPlayer, true)
        for groupName, hasGroup in pairs(updatedPlayerData.groups) do
            if hasGroup and priorities[groupName] and priorities[groupName] > highestPriority then
                highestPriority = priorities[groupName]
                highestGroup = groupName
            end
        end
        
        print("ğŸ”„ Grupos apÃ³s adiÃ§Ã£o:", game:GetService("HttpService"):JSONEncode(updatedPlayerData.groups))
        print("ğŸ† Grupo mais alto:", highestGroup)
        
        -- Enviar atualizaÃ§Ã£o para todos os clientes
        groupSyncEvent:FireAllClients(targetPlayer, highestGroup)
    else
        print("âŒ Erro ao adicionar grupo!")
    end
end)
