local STORAGE_DEFINITIONS = require(game.ReplicatedStorage.Shared.storage)
local STORAGE_KEY = STORAGE_DEFINITIONS.playerItems
local ORDER_STORAGE_KEY = STORAGE_DEFINITIONS.itemsOrder
local HOTBAR_STORAGE_KEY = STORAGE_DEFINITIONS.hotbarItems
local ITEMS_MODULE = require(game.ReplicatedStorage.Shared.itens)
local ITEMS_CONFIG = ITEMS_MODULE.list
local MAX_HOTBAR_SLOTS = ITEMS_MODULE.maxHotbarSlots or 4
local DataStoreService = game:GetService("DataStoreService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

local playerItemsStore = DataStoreService:GetDataStore(STORAGE_KEY)
local itemsOrderStore = DataStoreService:GetDataStore(ORDER_STORAGE_KEY)
local hotbarStore = DataStoreService:GetDataStore(HOTBAR_STORAGE_KEY)
local playerItemsCache = {} -- Cache: userId -> {itemId -> quantidade}
local playerOrderCache = {} -- Cache: userId -> {itemId -> posi√ß√£o}
local hotbarCache = {} -- Cache: userId -> {[slotIndex] = {itemId, quantity}}

-- RemoteEvents
local getPlayerItemsEvent = Instance.new("RemoteFunction")
getPlayerItemsEvent.Name = "GetPlayerItems"
getPlayerItemsEvent.Parent = ReplicatedStorage

local updatePlayerItemsEvent = Instance.new("RemoteEvent")
updatePlayerItemsEvent.Name = "UpdatePlayerItems"
updatePlayerItemsEvent.Parent = ReplicatedStorage

local reorderItemsEvent = Instance.new("RemoteEvent")
reorderItemsEvent.Name = "ReorderItems"
reorderItemsEvent.Parent = ReplicatedStorage

local getHotbarFunction = Instance.new("RemoteFunction")
getHotbarFunction.Name = "GetHotbar"
getHotbarFunction.Parent = ReplicatedStorage

local updateHotbarEvent = Instance.new("RemoteEvent")
updateHotbarEvent.Name = "UpdateHotbar"
updateHotbarEvent.Parent = ReplicatedStorage

local setHotbarSlotEvent = Instance.new("RemoteEvent")
setHotbarSlotEvent.Name = "SetHotbarSlot"
setHotbarSlotEvent.Parent = ReplicatedStorage

local swapHotbarSlotsEvent = Instance.new("RemoteEvent")
swapHotbarSlotsEvent.Name = "SwapHotbarSlots"
swapHotbarSlotsEvent.Parent = ReplicatedStorage

local moveHotbarToInventorySlotEvent = Instance.new("RemoteEvent")
moveHotbarToInventorySlotEvent.Name = "MoveHotbarToInventorySlot"
moveHotbarToInventorySlotEvent.Parent = ReplicatedStorage

local PlayerItemsModule = {}

--- Valida se um item existe na configura√ß√£o
local function isValidItem(itemId: number): boolean
    return type(itemId) == "number" and ITEMS_CONFIG[itemId] ~= nil
end

--- Valida se um item pode ser colocado na hotbar
local function canItemBeHotbar(itemId: number): boolean
    if not isValidItem(itemId) then return false end
    local itemConfig = ITEMS_CONFIG[itemId]
    -- Se canHotbar n√£o est√° definido, assume true
    return itemConfig.canHotbar ~= false
end

--- Envia atualiza√ß√£o de itens E ordem para o cliente
local function notifyClient(player: Player)
    local items = PlayerItemsModule.getPlayerItemsWithInfo(player)  -- ‚úÖ Retorna com info completa
    local order = PlayerItemsModule.getPlayerOrder(player)
    
    updatePlayerItemsEvent:FireClient(player, {items = items, order = order})
end

--- Envia atualiza√ß√£o da hotbar para o cliente
local function notifyHotbarClient(player: Player)
    local hotbar = PlayerItemsModule.getHotbar(player)
    
    -- Normalizar chaves antes de enviar (garantir que sejam n√∫meros)
    local normalizedHotbar = {}
    for slotIndex, slotData in pairs(hotbar) do
        local slotNum = tonumber(slotIndex)
        if slotNum then
            normalizedHotbar[slotNum] = slotData
        end
    end
    
    updateHotbarEvent:FireClient(player, normalizedHotbar)
end

--- Envia atualiza√ß√£o completa (invent√°rio + hotbar) para o cliente
--- Usa isso para opera√ß√µes que afetam ambos simultaneamente
local function notifyFullState(player: Player)
    local items = PlayerItemsModule.getPlayerItemsWithInfo(player)  -- ‚úÖ Retorna com info completa
    local order = PlayerItemsModule.getPlayerOrder(player)
    local hotbar = PlayerItemsModule.getHotbar(player)
    
    -- Normalizar chaves da hotbar antes de enviar (garantir que sejam n√∫meros)
    local normalizedHotbar = {}
    for slotIndex, slotData in pairs(hotbar) do
        local slotNum = tonumber(slotIndex)
        if slotNum then
            normalizedHotbar[slotNum] = slotData
        end
    end
    
    -- Enviar ambos (cliente receber√° na ordem correta)
    updatePlayerItemsEvent:FireClient(player, {items = items, order = order})
    updateHotbarEvent:FireClient(player, normalizedHotbar)
end

--- Valida dados de itens
local function validateItemsData(items: {[number]: number}): boolean
    if type(items) ~= "table" then
        return false
    end
    
    for itemId, quantity in pairs(items) do
        local itemIdNum = tonumber(itemId)  -- Converter para n√∫mero (DataStore pode retornar string)
        if not itemIdNum or not isValidItem(itemIdNum) or type(quantity) ~= "number" or quantity < 0 then
            return false
        end
    end
    
    return true
end

--- Carrega itens do jogador do DataStore
function PlayerItemsModule.loadPlayerItems(player: Player): {[number]: number}
    local userId = tostring(player.UserId)
    
    local success, items = pcall(function()
        return playerItemsStore:GetAsync(userId)
    end)
    
    local playerItems = {}
    
    if success and items and type(items) == "table" then
        -- Validar e filtrar itens inv√°lidos
        for itemId, quantity in pairs(items) do
            -- üîß Converter itemId para n√∫mero (DataStore pode retornar como string)
            local itemIdNum = tonumber(itemId)
            
            if itemIdNum and isValidItem(itemIdNum) and type(quantity) == "number" and quantity > 0 then
                playerItems[itemIdNum] = quantity  -- Usar n√∫mero ao inv√©s de string
            else
                print("  ‚ùå Inv√°lido! itemIdNum:", itemIdNum, "isValidItem:", itemIdNum and isValidItem(itemIdNum) or "false")
            end
        end
    end
    
    playerItemsCache[player.UserId] = playerItems
    return playerItems
end

--- Salva itens do jogador no DataStore
function PlayerItemsModule.savePlayerItems(player: Player): boolean
    local userId = player.UserId
    local items = playerItemsCache[userId] or {}
    
    if not validateItemsData(items) then
        warn("‚ùå Dados de itens inv√°lidos para jogador:", player.Name)
        return false
    end
    
    local success = pcall(function()
        playerItemsStore:SetAsync(tostring(userId), items)
    end)
    
    if not success then
        warn("‚ùå Erro ao salvar itens para jogador:", player.Name)
    end
    
    return success
end

--- Obt√©m itens do jogador (com cache)
function PlayerItemsModule.getPlayerItems(player: Player): {[number]: number}
    if not playerItemsCache[player.UserId] then
        PlayerItemsModule.loadPlayerItems(player)
    end
    
    local items = playerItemsCache[player.UserId] or {}
    
    return items
end

--- Adiciona item ao invent√°rio do jogador
--- @param shouldNotify (opcional) Se deve notificar o cliente (default: true)
function PlayerItemsModule.addItem(player: Player, itemId: number, quantity: number?, shouldNotify: boolean?): boolean
    if not isValidItem(itemId) then
        warn("‚ùå Item ID inv√°lido:", itemId)
        return false
    end
    
    local amount = quantity or 1
    if type(amount) ~= "number" or amount <= 0 then
        warn("‚ùå Quantidade inv√°lida:", amount)
        return false
    end
    
    -- Inicializa cache se necess√°rio
    if not playerItemsCache[player.UserId] then
        playerItemsCache[player.UserId] = {}
    end
    if not playerOrderCache[player.UserId] then
        playerOrderCache[player.UserId] = {}
    end
    
    local playerItems = playerItemsCache[player.UserId]
    local order = playerOrderCache[player.UserId]
    local currentAmount = playerItems[itemId] or 0
    local itemConfig = ITEMS_CONFIG[itemId]
    
    -- üîß Criar entradas na ordem para items n√£o-stackable
    if itemConfig and not itemConfig.stackable then
        -- Para cada nova unidade, criar um uniqueId e encontrar posi√ß√£o livre
        for i = 1, amount do
            local newIndex = currentAmount + i
            local uniqueId = tostring(itemId) .. "_" .. tostring(newIndex)
            
            -- Encontrar pr√≥xima posi√ß√£o livre
            local usedPositions = {}
            for _, pos in pairs(order) do
                usedPositions[pos] = true
            end
            
            local nextPosition = 1
            while usedPositions[nextPosition] do
                nextPosition = nextPosition + 1
            end
            
            order[uniqueId] = nextPosition
        end
    end
    
    playerItems[itemId] = currentAmount + amount
    
    -- Salvar AMBOS no DataStore
    local successItems = PlayerItemsModule.savePlayerItems(player)
    local successOrder = PlayerItemsModule.savePlayerOrder(player)
    
    if successItems and successOrder and (shouldNotify == nil or shouldNotify == true) then
        -- Notificar cliente com itens E ordem (apenas se shouldNotify n√£o for false)
        notifyClient(player)
    end
    
    return successItems and successOrder
end

--- Remove item do invent√°rio do jogador
--- @param shouldNotify (opcional) Se deve notificar o cliente (default: true)
function PlayerItemsModule.removeItem(player: Player, itemId: number, quantity: number?, shouldNotify: boolean?): boolean
    if not isValidItem(itemId) then
        warn("‚ùå Item ID inv√°lido:", itemId)
        return false
    end
    
    local amount = quantity or 1
    if type(amount) ~= "number" or amount <= 0 then
        warn("‚ùå Quantidade inv√°lida:", amount)
        return false
    end
    
    local playerItems = PlayerItemsModule.getPlayerItems(player)
    local currentAmount = playerItems[itemId] or 0
    
    if currentAmount < amount then
        warn("‚ùå Jogador n√£o tem quantidade suficiente do item")
        return false
    end
    
    local newAmount = currentAmount - amount
    if newAmount <= 0 then
        playerItems[itemId] = nil
    else
        playerItems[itemId] = newAmount
    end
    
    -- Salvar no DataStore
    local success = PlayerItemsModule.savePlayerItems(player)
    
    if success and (shouldNotify == nil or shouldNotify == true) then
        -- Notificar cliente com itens E ordem (apenas se shouldNotify n√£o for false)
        notifyClient(player)
    end
    
    return success
end

--- Define quantidade exata de um item
function PlayerItemsModule.setItem(player: Player, itemId: number, quantity: number): boolean
    if not isValidItem(itemId) then
        warn("‚ùå Item ID inv√°lido:", itemId)
        return false
    end
    
    if type(quantity) ~= "number" or quantity < 0 then
        warn("‚ùå Quantidade inv√°lida:", quantity)
        return false
    end
    
    -- Inicializa cache se necess√°rio
    if not playerItemsCache[player.UserId] then
        playerItemsCache[player.UserId] = {}
    end
    
    local playerItems = playerItemsCache[player.UserId]
    
    if quantity == 0 then
        playerItems[itemId] = nil
    else
        playerItems[itemId] = quantity
    end
    
    -- Salvar no DataStore
    local success = PlayerItemsModule.savePlayerItems(player)
    
    if success then
        -- Notificar cliente com itens E ordem
        notifyClient(player)
    end
    
    return success
end

--- Verifica se o jogador possui um item
function PlayerItemsModule.hasItem(player: Player, itemId: number, quantity: number?): boolean
    if not isValidItem(itemId) then
        return false
    end
    
    local playerItems = PlayerItemsModule.getPlayerItems(player)
    local currentAmount = playerItems[itemId] or 0
    local requiredAmount = quantity or 1
    
    return currentAmount >= requiredAmount
end

--- Obt√©m quantidade de um item espec√≠fico
function PlayerItemsModule.getItemQuantity(player: Player, itemId: number): number
    if not isValidItem(itemId) then
        return 0
    end
    
    local playerItems = PlayerItemsModule.getPlayerItems(player)
    return playerItems[itemId] or 0
end

--- Limpa todos os itens do jogador
function PlayerItemsModule.clearAllItems(player: Player): boolean
    playerItemsCache[player.UserId] = {}
    playerOrderCache[player.UserId] = {}
    hotbarCache[player.UserId] = {}
    
    local successItems = PlayerItemsModule.savePlayerItems(player)
    local successOrder = PlayerItemsModule.savePlayerOrder(player)
    local successHotbar = PlayerItemsModule.saveHotbar(player)
    
    if successItems and successOrder and successHotbar then
        -- Notificar cliente com estado completo vazio
        updatePlayerItemsEvent:FireClient(player, {items = {}, order = {}})
        updateHotbarEvent:FireClient(player, {})
        return true
    else
        warn("‚ùå Erro ao limpar todos os itens")
        return false
    end
end

--- Obt√©m informa√ß√µes completas dos itens do jogador (com dados da config)
function PlayerItemsModule.getPlayerItemsWithInfo(player: Player): {[number]: {item: any, quantity: number}}
    local playerItems = PlayerItemsModule.getPlayerItems(player)
    local itemsWithInfo = {}
    
    for itemId, quantity in pairs(playerItems) do
        local itemConfig = ITEMS_CONFIG[itemId]
        if itemConfig then
            itemsWithInfo[itemId] = {
                item = itemConfig,
                quantity = quantity
            }
        end
    end
    
    return itemsWithInfo
end

--- Carrega a ordem dos itens do jogador do DataStore
function PlayerItemsModule.loadPlayerOrder(player: Player): {[any]: number}
    local userId = tostring(player.UserId)
    
    local success, order = pcall(function()
        return itemsOrderStore:GetAsync(userId)
    end)
    
    local playerOrder = {}
    
    if success and order and type(order) == "table" then
        playerOrder = order
    end
    
    playerOrderCache[player.UserId] = playerOrder
    return playerOrder
end

--- Salva a ordem dos itens do jogador no DataStore
function PlayerItemsModule.savePlayerOrder(player: Player): boolean
    local userId = player.UserId
    local order = playerOrderCache[userId] or {}
    
    local success = pcall(function()
        itemsOrderStore:SetAsync(tostring(userId), order)
    end)
    
    if not success then
        warn("‚ùå Erro ao salvar ordem de itens para jogador:", player.Name)
    end
    
    return success
end

--- Obt√©m a ordem dos itens do jogador (com cache)
function PlayerItemsModule.getPlayerOrder(player: Player): {[any]: number}
    if not playerOrderCache[player.UserId] then
        PlayerItemsModule.loadPlayerOrder(player)
    end
    
    return playerOrderCache[player.UserId] or {}
end

--- Reordena os itens do jogador
function PlayerItemsModule.reorderItems(player: Player, newOrder: any): boolean
    if not newOrder or type(newOrder) ~= "table" then
        warn("‚ùå Ordem de itens inv√°lida")
        return false
    end
    
    -- Validar que todos os itemIds na ordem existem no invent√°rio do jogador
    local playerItems = PlayerItemsModule.getPlayerItems(player)
    for uniqueId, position in pairs(newOrder) do
        -- Extrair itemId do uniqueId (pode ser "1" ou "1_2")
        local itemIdStr = string.match(tostring(uniqueId), "^(%d+)")
        local itemId = tonumber(itemIdStr)
        
        if not itemId or not playerItems[itemId] then
            warn("‚ùå Tentativa de reordenar item que o jogador n√£o possui:", uniqueId, itemId)
            return false
        end
        
        if type(position) ~= "number" or position < 0 then
            warn("‚ùå Posi√ß√£o inv√°lida para item:", uniqueId)
            return false
        end
    end
    
    -- Atualizar cache
    playerOrderCache[player.UserId] = newOrder
    
    -- Salvar no DataStore
    return PlayerItemsModule.savePlayerOrder(player)
end

-- ========================================
-- FUN√á√ïES DE HOTBAR
-- ========================================

--- Carrega hotbar do jogador do DataStore
function PlayerItemsModule.loadHotbar(player: Player): {[number]: {itemId: number, quantity: number}?}
    local userId = tostring(player.UserId)
    
    local success, hotbar = pcall(function()
        return hotbarStore:GetAsync(userId)
    end)
    
    local playerHotbar = {}
    
    if success and hotbar and type(hotbar) == "table" then
        -- Validar e filtrar slots inv√°lidos
        for slotIndex, slotData in pairs(hotbar) do
            -- DataStore SEMPRE converte chaves num√©ricas em strings, converter de volta
            local slotNum = tonumber(slotIndex)
            
            if slotNum and slotNum >= 1 and slotNum <= MAX_HOTBAR_SLOTS then
                if type(slotData) == "table" and slotData.itemId and slotData.quantity then
                    if isValidItem(slotData.itemId) and canItemBeHotbar(slotData.itemId) then
                        -- Garantir que salvamos com chave num√©rica no cache
                        playerHotbar[slotNum] = {
                            itemId = slotData.itemId,
                            quantity = slotData.quantity
                        }
                    end
                end
            end
        end
    end
    
    hotbarCache[player.UserId] = playerHotbar
    return playerHotbar
end

--- Salva hotbar do jogador no DataStore
function PlayerItemsModule.saveHotbar(player: Player): boolean
    local userId = player.UserId
    local hotbar = hotbarCache[userId] or {}
    
    local success = pcall(function()
        hotbarStore:SetAsync(tostring(userId), hotbar)
    end)
    
    if not success then
        warn("‚ùå Erro ao salvar hotbar para jogador:", player.Name)
    end
    
    return success
end

--- Obt√©m hotbar do jogador (com cache)
function PlayerItemsModule.getHotbar(player: Player): {[number]: {itemId: number, quantity: number}?}
    if not hotbarCache[player.UserId] then
        PlayerItemsModule.loadHotbar(player)
    end
    
    -- Cache j√° deve ter chaves normalizadas, mas garantir
    local hotbar = hotbarCache[player.UserId] or {}
    
    -- Validar que todas as chaves s√£o n√∫meros (seguran√ßa extra)
    local normalizedHotbar = {}
    for slotIndex, slotData in pairs(hotbar) do
        if type(slotIndex) == "number" then
            normalizedHotbar[slotIndex] = slotData
        else
            -- Se por algum motivo h√° uma string, tentar converter
            local slotNum = tonumber(slotIndex)
            if slotNum then
                normalizedHotbar[slotNum] = slotData
            end
        end
    end
    
    return normalizedHotbar
end

--- Define um slot da hotbar (move item do invent√°rio para hotbar)
function PlayerItemsModule.setHotbarSlot(player: Player, slotIndex: number, itemId: number?, quantity: number?): boolean
    print("üîß [setHotbarSlot] Iniciando processamento...")
    
    -- Validar slot
    if type(slotIndex) ~= "number" or slotIndex < 1 or slotIndex > MAX_HOTBAR_SLOTS then
        warn("‚ùå Slot de hotbar inv√°lido:", slotIndex)
        return false
    end
    print("  ‚úÖ Slot v√°lido:", slotIndex)
    
    -- Inicializar cache se necess√°rio
    if not hotbarCache[player.UserId] then
        hotbarCache[player.UserId] = {}
    end
    
    local hotbar = hotbarCache[player.UserId]
    
    -- Se itemId √© nil, est√° limpando o slot (mover de volta para invent√°rio)
    if not itemId then
        local oldSlotData = hotbar[slotIndex]
        if oldSlotData then
            -- Devolver item ao invent√°rio (SEM notificar ainda)
            PlayerItemsModule.addItem(player, oldSlotData.itemId, oldSlotData.quantity, false)
            
            -- üìç IMPORTANTE: Adicionar posi√ß√£o no order para o item devolvido
            local order = playerOrderCache[player.UserId]
            if order then
                local oldItemConfig = ITEMS_CONFIG[oldSlotData.itemId]
                local oldItemId = oldSlotData.itemId
                local playerItems = playerItemsCache[player.UserId]
                
                -- Determinar uniqueId para o item devolvido
                local uniqueId
                if oldItemConfig and oldItemConfig.stackable then
                    -- Item stackable: usar apenas o itemId
                    uniqueId = tostring(oldItemId)
                else
                    -- Item n√£o-stackable: usar quantidade total no invent√°rio
                    local totalInInventory = playerItems[oldItemId] or 0
                    uniqueId = tostring(oldItemId) .. "_" .. tostring(totalInInventory)
                end
                
                -- Encontrar pr√≥ximo slot livre
                local usedPositions = {}
                for _, pos in pairs(order) do
                    usedPositions[pos] = true
                end
                
                local nextPosition = 1
                while usedPositions[nextPosition] do
                    nextPosition = nextPosition + 1
                end
                
                order[uniqueId] = nextPosition
                -- print("   üìç Item devolvido ao invent√°rio:", uniqueId, "‚Üí pos", nextPosition)
            end
            
            hotbar[slotIndex] = nil
            -- print("‚úÖ Slot", slotIndex, "limpo: Item", oldSlotData.itemId, "devolvido ao invent√°rio")
        end
    else
        -- Validar item
        if not isValidItem(itemId) then
            warn("‚ùå Item ID inv√°lido:", itemId)
            return false
        end
        
        if not canItemBeHotbar(itemId) then
            warn("‚ùå Item n√£o pode ser colocado na hotbar:", itemId)
            return false
        end
        
        local amount = quantity or 1
        if type(amount) ~= "number" or amount <= 0 then
            warn("‚ùå Quantidade inv√°lida:", amount)
            return false
        end
        
        -- Verificar se jogador tem o item no invent√°rio
        print("  üì¶ Verificando se player tem item", itemId, "x", amount)
        local hasItem = PlayerItemsModule.hasItem(player, itemId, amount)
        print("  üì¶ Player tem item?", hasItem)
        
        if not hasItem then
            warn("‚ùå Jogador n√£o possui item suficiente no invent√°rio")
            local playerItems = playerItemsCache[player.UserId]
            if playerItems then
                print("  üì¶ Itens do jogador:", game:GetService("HttpService"):JSONEncode(playerItems))
            end
            return false
        end
        
        -- Se j√° tem algo no slot, devolver ao invent√°rio primeiro (SEM notificar)
        local oldSlotData = hotbar[slotIndex]
        if oldSlotData then
            PlayerItemsModule.addItem(player, oldSlotData.itemId, oldSlotData.quantity, false)
            
            -- üìç IMPORTANTE: Adicionar posi√ß√£o no order para o item devolvido
            local order = playerOrderCache[player.UserId]
            if order then
                local oldItemConfig = ITEMS_CONFIG[oldSlotData.itemId]
                local oldItemId = oldSlotData.itemId
                local playerItems = playerItemsCache[player.UserId]
                
                -- Determinar uniqueId para o item devolvido
                local uniqueId
                if oldItemConfig and oldItemConfig.stackable then
                    -- Item stackable: usar apenas o itemId
                    uniqueId = tostring(oldItemId)
                else
                    -- Item n√£o-stackable: usar quantidade total no invent√°rio
                    local totalInInventory = playerItems[oldItemId] or 0
                    uniqueId = tostring(oldItemId) .. "_" .. tostring(totalInInventory)
                end
                
                -- Encontrar pr√≥ximo slot livre
                local usedPositions = {}
                for _, pos in pairs(order) do
                    usedPositions[pos] = true
                end
                
                local nextPosition = 1
                while usedPositions[nextPosition] do
                    nextPosition = nextPosition + 1
                end
                
                order[uniqueId] = nextPosition
                --print("   üìç Item devolvido ao invent√°rio:", uniqueId, "‚Üí pos", nextPosition)
            end
        end
        
        -- üêõ BUG FIX: Remover do order ANTES de remover do invent√°rio
        local order = playerOrderCache[player.UserId]
        if order then
            local itemConfig = ITEMS_CONFIG[itemId]
            
            -- Determinar uniqueId para remover do order
            if itemConfig and itemConfig.stackable then
                -- Item stackable: usar apenas o itemId
                local uniqueId = tostring(itemId)
                order[uniqueId] = nil
                print("  üóëÔ∏è Removido do order:", uniqueId)
            else
                -- Item n√£o-stackable: remover TODAS as unidades deste item do order
                -- porque vamos remover do invent√°rio
                local itemsToRemove = {}
                for uniqueId, _ in pairs(order) do
                    local idStr = string.match(tostring(uniqueId), "^(%d+)")
                    local uniqueItemId = tonumber(idStr)
                    if uniqueItemId == itemId then
                        table.insert(itemsToRemove, uniqueId)
                    end
                end
                
                -- Remover apenas a quantidade necess√°ria
                for i = 1, math.min(amount, #itemsToRemove) do
                    order[itemsToRemove[i]] = nil
                    print("  üóëÔ∏è Removido do order:", itemsToRemove[i])
                end
            end
        end
        
        -- Remover do invent√°rio (SEM notificar)
        PlayerItemsModule.removeItem(player, itemId, amount, false)
        
        -- Adicionar ao slot da hotbar
        hotbar[slotIndex] = {
            itemId = itemId,
            quantity = amount
        }
    end
    
    -- Salvar todos os dados
    local successItems = PlayerItemsModule.savePlayerItems(player)
    local successOrder = PlayerItemsModule.savePlayerOrder(player)
    local successHotbar = PlayerItemsModule.saveHotbar(player)
    
    print("  üíæ Salvando dados... Items:", successItems, "Order:", successOrder, "Hotbar:", successHotbar)
    
    if successItems and successOrder and successHotbar then
        print("  üì§ Notificando cliente com estado completo")
        -- Notificar TUDO de uma vez (estado completo e consistente)
        notifyFullState(player)
        print("  ‚úÖ SetHotbarSlot conclu√≠do com sucesso!")
        return true
    else
        warn("‚ùå Erro ao salvar dados do jogador")
        return false
    end
end

--- Remove item da hotbar e devolve ao invent√°rio
function PlayerItemsModule.clearHotbarSlot(player: Player, slotIndex: number): boolean
    return PlayerItemsModule.setHotbarSlot(player, slotIndex, nil, nil)
end

--- Faz swap entre dois slots da hotbar (sem mexer no invent√°rio)
function PlayerItemsModule.swapHotbarSlots(player: Player, slotIndex1: number, slotIndex2: number): boolean
    -- Validar slots
    if type(slotIndex1) ~= "number" or slotIndex1 < 1 or slotIndex1 > MAX_HOTBAR_SLOTS then
        warn("‚ùå Slot 1 de hotbar inv√°lido:", slotIndex1)
        return false
    end
    
    if type(slotIndex2) ~= "number" or slotIndex2 < 1 or slotIndex2 > MAX_HOTBAR_SLOTS then
        warn("‚ùå Slot 2 de hotbar inv√°lido:", slotIndex2)
        return false
    end
    
    if slotIndex1 == slotIndex2 then
        warn("‚ùå Slots s√£o iguais")
        return false
    end
    
    -- Inicializar cache se necess√°rio
    if not hotbarCache[player.UserId] then
        hotbarCache[player.UserId] = {}
    end
    
    local hotbar = hotbarCache[player.UserId]
    
    -- Fazer swap simples (pode ser nil em um ou ambos os slots)
    local temp = hotbar[slotIndex1]
    hotbar[slotIndex1] = hotbar[slotIndex2]
    hotbar[slotIndex2] = temp
    
    -- Salvar hotbar
    local success = PlayerItemsModule.saveHotbar(player)
    
    if success then
        -- Notificar apenas hotbar (invent√°rio n√£o mudou)
        notifyHotbarClient(player)
        return true
    else
        warn("‚ùå Erro ao salvar hotbar ap√≥s swap")
        return false
    end
end

--- Move item da hotbar para um slot espec√≠fico do invent√°rio
function PlayerItemsModule.moveHotbarToInventorySlot(player: Player, hotbarSlotIndex: number, targetLayoutOrder: number): boolean
    print("üîß [moveHotbarToInventorySlot] Recebido:")
    print("  - Player:", player.Name)
    print("  - Hotbar Slot:", hotbarSlotIndex)
    print("  - Target Layout Order:", targetLayoutOrder)
    
    -- Validar hotbar slot
    if type(hotbarSlotIndex) ~= "number" or hotbarSlotIndex < 1 or hotbarSlotIndex > MAX_HOTBAR_SLOTS then
        warn("‚ùå Slot de hotbar inv√°lido:", hotbarSlotIndex)
        return false
    end
    
    -- Validar layout order
    if type(targetLayoutOrder) ~= "number" or targetLayoutOrder < 1 then
        warn("‚ùå Layout order inv√°lido:", targetLayoutOrder)
        return false
    end
    
    print("  ‚úÖ Valida√ß√µes passaram")
    
    -- Inicializar caches se necess√°rio
    if not hotbarCache[player.UserId] then
        hotbarCache[player.UserId] = {}
    end
    if not playerOrderCache[player.UserId] then
        playerOrderCache[player.UserId] = {}
    end
    if not playerItemsCache[player.UserId] then
        playerItemsCache[player.UserId] = {}
    end
    
    local hotbar = hotbarCache[player.UserId]
    local order = playerOrderCache[player.UserId]
    local playerItems = playerItemsCache[player.UserId]
    
    -- Obter dados do slot da hotbar
    local slotData = hotbar[hotbarSlotIndex]
    if not slotData then
        warn("‚ùå Slot da hotbar est√° vazio:", hotbarSlotIndex)
        return false
    end
    
    local hotbarItemId = slotData.itemId
    local hotbarQuantity = slotData.quantity
    
    -- Verificar se existe um item na posi√ß√£o alvo (para fazer SWAP)
    local conflictingUniqueId = nil
    local conflictingItemId = nil
    
    print("  üîç Verificando itens na posi√ß√£o", targetLayoutOrder)
    print("  üîç Order atual:", order)
    
    for uniqueId, layoutOrder in pairs(order) do
        if layoutOrder == targetLayoutOrder then
            conflictingUniqueId = uniqueId
            -- Extrair itemId do uniqueId
            local idStr = string.match(tostring(uniqueId), "^(%d+)")
            conflictingItemId = tonumber(idStr)
            print("  ‚ö†Ô∏è Encontrado item conflitante:", uniqueId, "na pos", layoutOrder)
            break
        end
    end
    
    if not conflictingItemId then
        print("  ‚úÖ Posi√ß√£o est√° vazia, apenas mover")
    end
    
    -- Se h√° item no slot alvo, fazer SWAP (ou MERGE se for mesmo item stackable)
    if conflictingItemId and conflictingUniqueId then  
        local inventoryItemConfig = ITEMS_CONFIG[conflictingItemId]
        local inventoryQuantity = 1 -- Itens n√£o-stackable sempre s√£o 1
        
        -- Se √© stackable, pegar quantidade do invent√°rio
        if inventoryItemConfig and inventoryItemConfig.stackable then
            inventoryQuantity = playerItems[conflictingItemId] or 1
        end
        
        print("üîÑ Conflito detectado! Hotbar slot", hotbarSlotIndex, "com Invent√°rio pos", targetLayoutOrder)
        print("  - Item na hotbar:", hotbarItemId, "qty:", hotbarQuantity)
        print("  - Item no inventory:", conflictingItemId, "qty:", inventoryQuantity)
        
        -- üêõ BUG FIX: Se for o MESMO item e STACKABLE, fazer MERGE ao inv√©s de SWAP
        local hotbarItemConfig = ITEMS_CONFIG[hotbarItemId]
        if hotbarItemId == conflictingItemId and hotbarItemConfig and hotbarItemConfig.stackable then
            print("  üîó MERGE! Mesmo item stackable, combinando quantidades")
            
            -- Adicionar quantidade da hotbar ao invent√°rio (sem notificar)
            PlayerItemsModule.addItem(player, hotbarItemId, hotbarQuantity, false)
            
            -- Remover da hotbar
            hotbar[hotbarSlotIndex] = nil
            
            -- Garantir que o order est√° na posi√ß√£o correta
            order[conflictingUniqueId] = targetLayoutOrder
            
            print("  üì¶ Total no invent√°rio agora:", playerItems[hotbarItemId], "na pos", targetLayoutOrder)
            
            -- Salvar e notificar
            local successItems = PlayerItemsModule.savePlayerItems(player)
            local successOrder = PlayerItemsModule.savePlayerOrder(player)
            local successHotbar = PlayerItemsModule.saveHotbar(player)
            
            print("  üíæ Salvando... Items:", successItems, "Order:", successOrder, "Hotbar:", successHotbar)
            
            if successItems and successOrder and successHotbar then
                notifyFullState(player)
                print("  ‚úÖ MERGE completo:", hotbarQuantity + inventoryQuantity, "unidades em pos", targetLayoutOrder)
                return true
            else
                warn("‚ùå Erro ao salvar dados do jogador")
                return false
            end
        end
        
        print("  üîÑ SWAP! Items diferentes, trocando posi√ß√µes")
        
        -- 1. Remover item do invent√°rio (que vai para hotbar)
        if not canItemBeHotbar(conflictingItemId) then
            warn("‚ùå Item do invent√°rio n√£o pode ir para hotbar:", conflictingItemId)
            return false
        end
        
        PlayerItemsModule.removeItem(player, conflictingItemId, inventoryQuantity, false)
        order[conflictingUniqueId] = nil
        
        -- 2. Adicionar item do invent√°rio na hotbar
        hotbar[hotbarSlotIndex] = {
            itemId = conflictingItemId,
            quantity = inventoryQuantity
        }
        
        -- 3. Adicionar item da hotbar no invent√°rio
        PlayerItemsModule.addItem(player, hotbarItemId, hotbarQuantity, false)
        
        -- 4. Atualizar ordem do item da hotbar (agora no invent√°rio)
        local hotbarItemConfig = ITEMS_CONFIG[hotbarItemId]
        local newUniqueId
        if hotbarItemConfig and hotbarItemConfig.stackable then
            newUniqueId = tostring(hotbarItemId)
        else
            -- Para n√£o-stackable, precisamos contar TODAS as unidades no playerItems
            local totalInInventory = playerItems[hotbarItemId] or 0
            -- O novo item ser√° o √∫ltimo (totalInInventory porque addItem j√° adicionou)
            newUniqueId = tostring(hotbarItemId) .. "_" .. tostring(totalInInventory)
        end
        order[newUniqueId] = targetLayoutOrder
        
        print("   üìç Definida posi√ß√£o:", newUniqueId, "‚Üí", targetLayoutOrder)
        print("   ‚úÖ SWAP completo: Item", conflictingItemId, "‚Üí hotbar,", "Item", hotbarItemId, "‚Üí invent√°rio pos", targetLayoutOrder)
    else
        -- N√£o h√° swap, apenas mover para invent√°rio
        -- Devolver item ao invent√°rio (SEM notificar)
        local addSuccess = PlayerItemsModule.addItem(player, hotbarItemId, hotbarQuantity, false)
        if not addSuccess then
            warn("‚ùå Erro ao devolver item ao invent√°rio")
            return false
        end
        
        -- Limpar slot da hotbar
        hotbar[hotbarSlotIndex] = nil
        
        -- Atualizar ordem para a nova posi√ß√£o
        local itemConfig = ITEMS_CONFIG[hotbarItemId]
        
        -- Determinar uniqueId do novo item
        local newUniqueId
        if itemConfig and itemConfig.stackable then
            -- Item stackable: usar apenas o itemId
            newUniqueId = tostring(hotbarItemId)
        else
            -- Item n√£o-stackable: usar a quantidade total no invent√°rio
            local totalInInventory = playerItems[hotbarItemId] or 0
            -- O novo item ser√° o √∫ltimo (totalInInventory porque addItem j√° adicionou)
            newUniqueId = tostring(hotbarItemId) .. "_" .. tostring(totalInInventory)
        end
        
        -- Colocar novo item na posi√ß√£o desejada
        order[newUniqueId] = targetLayoutOrder
        print("  üìç Definida posi√ß√£o:", newUniqueId, "‚Üí", targetLayoutOrder)
        print("  ‚úÖ Item movido para invent√°rio (sem swap)")
    end
    
    -- Salvar ambos
    local successItems = PlayerItemsModule.savePlayerItems(player)
    local successOrder = PlayerItemsModule.savePlayerOrder(player)
    local successHotbar = PlayerItemsModule.saveHotbar(player)
    
    print("  üíæ Salvando... Items:", successItems, "Order:", successOrder, "Hotbar:", successHotbar)
    
    if successItems and successOrder and successHotbar then
        -- Notificar estado completo
        notifyFullState(player)
        print("  ‚úÖ Item", hotbarItemId, "movido da hotbar slot", hotbarSlotIndex, "‚Üí invent√°rio pos", targetLayoutOrder)
        return true
    else
        warn("‚ùå Erro ao salvar dados do jogador")
        return false
    end
end

--- Usa item da hotbar (reduz quantidade em 1)
function PlayerItemsModule.useHotbarItem(player: Player, slotIndex: number): boolean
    if type(slotIndex) ~= "number" or slotIndex < 1 or slotIndex > MAX_HOTBAR_SLOTS then
        return false
    end
    
    local hotbar = PlayerItemsModule.getHotbar(player)
    local slotData = hotbar[slotIndex]
    
    if not slotData then
        return false
    end
    
    -- Reduzir quantidade
    slotData.quantity = slotData.quantity - 1
    
    -- Se quantidade chegou a 0, remover do slot
    if slotData.quantity <= 0 then
        hotbar[slotIndex] = nil
    end
    
    -- Salvar e notificar
    PlayerItemsModule.saveHotbar(player)
    notifyHotbarClient(player)
    
    return true
end

--- Limpa toda a hotbar (devolve tudo ao invent√°rio)
function PlayerItemsModule.clearHotbar(player: Player): boolean
    local hotbar = PlayerItemsModule.getHotbar(player)
    
    -- Devolver todos os itens ao invent√°rio (SEM notificar)
    for slotIndex, slotData in pairs(hotbar) do
        if slotData then
            PlayerItemsModule.addItem(player, slotData.itemId, slotData.quantity, false)
        end
    end
    
    -- Limpar hotbar
    hotbarCache[player.UserId] = {}
    
    -- Salvar ambos
    local successItems = PlayerItemsModule.savePlayerItems(player)
    local successHotbar = PlayerItemsModule.saveHotbar(player)
    
    if successItems and successHotbar then
        -- Notificar estado completo
        notifyFullState(player)
        return true
    else
        warn("‚ùå Erro ao limpar hotbar")
        return false
    end
end

--- Configurar RemoteFunction para obter itens
getPlayerItemsEvent.OnServerInvoke = function(player: Player)
    -- Retorna IDs, quantidades E ordem dos itens
    local items = PlayerItemsModule.getPlayerItemsWithInfo(player)  -- ‚úÖ Retorna com configura√ß√£o do item
    local order = PlayerItemsModule.getPlayerOrder(player)
    
    return {items = items, order = order}
end

--- Conectar RemoteEvent de reordenar
reorderItemsEvent.OnServerEvent:Connect(function(player, newOrder)
    PlayerItemsModule.reorderItems(player, newOrder)
end)

--- Configurar RemoteFunction para obter hotbar
getHotbarFunction.OnServerInvoke = function(player: Player)
    return PlayerItemsModule.getHotbar(player)
end

--- Conectar RemoteEvent para definir slot da hotbar
setHotbarSlotEvent.OnServerEvent:Connect(function(player, slotIndex, itemId, quantity)
    print("üì° [SERVER] Recebeu SetHotbarSlot:")
    print("  - Player:", player.Name)
    print("  - SlotIndex:", slotIndex, type(slotIndex))
    print("  - ItemId:", itemId, type(itemId))
    print("  - Quantity:", quantity, type(quantity))
    
    local success = PlayerItemsModule.setHotbarSlot(player, slotIndex, itemId, quantity)
    print("  - Resultado:", success and "‚úÖ Sucesso" or "‚ùå Falhou")
end)

--- Conectar RemoteEvent para fazer swap entre slots da hotbar
swapHotbarSlotsEvent.OnServerEvent:Connect(function(player, slotIndex1, slotIndex2)
    PlayerItemsModule.swapHotbarSlots(player, slotIndex1, slotIndex2)
end)

--- Conectar RemoteEvent para mover item da hotbar para slot espec√≠fico do invent√°rio
moveHotbarToInventorySlotEvent.OnServerEvent:Connect(function(player, hotbarSlotIndex, targetLayoutOrder)
    PlayerItemsModule.moveHotbarToInventorySlot(player, hotbarSlotIndex, targetLayoutOrder)
end)

--- Carregar itens, ordem e hotbar quando jogador entra
Players.PlayerAdded:Connect(function(player)
    task.spawn(function()
        PlayerItemsModule.loadPlayerItems(player)
        PlayerItemsModule.loadPlayerOrder(player)
        PlayerItemsModule.loadHotbar(player)
    end)
end)

--- Salvar e limpar cache quando jogador sai
Players.PlayerRemoving:Connect(function(player)
    if playerItemsCache[player.UserId] then
        PlayerItemsModule.savePlayerItems(player)
        PlayerItemsModule.savePlayerOrder(player)
        PlayerItemsModule.saveHotbar(player)
        task.wait(0.5) -- Garantir que salvou
        playerItemsCache[player.UserId] = nil
        playerOrderCache[player.UserId] = nil
        hotbarCache[player.UserId] = nil
    end
end)

--print("‚úÖ Sistema de Itens inicializado!")

return PlayerItemsModule

